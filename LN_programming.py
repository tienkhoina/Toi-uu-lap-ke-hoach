{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "import sys\n",
    "\n",
    "class LN_programming:\n",
    "    def __init__(self, n, F, A, B):\n",
    "        self.m = A.shape[0]  \n",
    "        self.n = n  \n",
    "        self.F = F  \n",
    "        self.A = A\n",
    "        self.B = B\n",
    "        self.x = np.zeros(n + self.m)  # ƒêi·ªÅu ch·ªânh k√≠ch th∆∞·ªõc x\n",
    "\n",
    "        # ƒêi·ªÅu ch·ªânh s·ªë c·ªôt ƒë·ªÉ ph√π h·ª£p v·ªõi bi·∫øn slack\n",
    "        self.Tab = np.zeros((self.m + 1, self.n + self.m + 1))  \n",
    "        self.Tab[:self.m, :self.n + self.m] = A\n",
    "        self.Tab[:self.m, self.n + self.m] = B\n",
    "        self.Tab[self.m, :n] = -F  \n",
    "\n",
    "    def check_optimal(self):\n",
    "        return not np.any(self.Tab[self.m, :self.n + self.m] < 0)\n",
    "\n",
    "    def check_unbounded(self, pivot_col):\n",
    "        return np.all(self.Tab[:self.m, pivot_col] <= 0)  \n",
    "\n",
    "    def pivot(self, pivot_row, pivot_col):\n",
    "        pivot_val = self.Tab[pivot_row, pivot_col]\n",
    "        self.Tab[pivot_row, :] /= pivot_val  \n",
    "        for i in range(self.m + 1):\n",
    "            if i != pivot_row:\n",
    "                factor = self.Tab[i, pivot_col]\n",
    "                self.Tab[i, :] -= factor * self.Tab[pivot_row, :]\n",
    "\n",
    "    def solve(self):\n",
    "        while not self.check_optimal():\n",
    "            pivot_col = np.argmin(self.Tab[self.m, :self.n + self.m])  \n",
    "            if self.check_unbounded(pivot_col):\n",
    "                return \"UNBOUNDED\"  \n",
    "\n",
    "            pivot_row = -1\n",
    "            min_ratio = sys.float_info.max\n",
    "            for i in range(self.m):\n",
    "                if self.Tab[i, pivot_col] > 0:\n",
    "                    ratio = self.Tab[i, self.n + self.m] / self.Tab[i, pivot_col]\n",
    "                    if ratio < min_ratio:\n",
    "                        min_ratio = ratio\n",
    "                        pivot_row = i\n",
    "\n",
    "            if pivot_row == -1:\n",
    "                return \"INFEASIBLE\"  \n",
    "\n",
    "            self.pivot(pivot_row, pivot_col) \n",
    "\n",
    "        return self.Tab[self.m, self.n + self.m]  \n",
    "\n",
    "    def setX(self):\n",
    "        for i in range(self.n + self.m):  # ƒêi·ªÅu ch·ªânh ƒë·ªÉ l·∫•y ƒë·ªß bi·∫øn quy·∫øt ƒë·ªãnh\n",
    "            if np.count_nonzero(self.Tab[:self.m, i] == 1) == 1 and np.count_nonzero(self.Tab[:self.m, i] == 0) == self.m - 1:\n",
    "                pivot_row = np.where(self.Tab[:self.m, i] == 1)[0][0]\n",
    "                self.x[i] = self.Tab[pivot_row, self.n + self.m]\n",
    "\n",
    "\n",
    "input_data = sys.stdin.read().strip().split(\"\\n\")\n",
    "\n",
    "if len(input_data) < 3:\n",
    "    print(\"L·ªói: D·ªØ li·ªáu ƒë·∫ßu v√†o kh√¥ng h·ª£p l·ªá!\")\n",
    "    exit()\n",
    "\n",
    "# üéØ ƒê·ªçc s·ªë bi·∫øn quy·∫øt ƒë·ªãnh v√† s·ªë r√†ng bu·ªôc\n",
    "n, m = map(int, input_data[0].split())\n",
    "\n",
    "# üéØ ƒê·ªçc h·ªá s·ªë h√†m m·ª•c ti√™u (F)\n",
    "F = np.array(list(map(float, input_data[1].split())))\n",
    "if len(F) != n:\n",
    "    print(\"L·ªói: S·ªë ph·∫ßn t·ª≠ c·ªßa F ph·∫£i b·∫±ng n!\")\n",
    "    exit()\n",
    "\n",
    "# üéØ ƒê·ªçc ma tr·∫≠n A\n",
    "A = np.array([list(map(float, input_data[i + 2].split())) for i in range(m)])\n",
    "if A.shape[1] != n:\n",
    "    print(\"L·ªói: K√≠ch th∆∞·ªõc ma tr·∫≠n A kh√¥ng ƒë√∫ng!\")\n",
    "    exit()\n",
    "\n",
    "# üéØ Th√™m bi·∫øn ph·ª• v√†o ma tr·∫≠n A\n",
    "A = np.hstack((A, np.identity(m)))\n",
    "\n",
    "# üéØ ƒê·ªçc vector B\n",
    "B = np.array(list(map(float, input_data[m + 2].split())))\n",
    "if len(B) != m:\n",
    "    print(\"L·ªói: S·ªë ph·∫ßn t·ª≠ c·ªßa B ph·∫£i b·∫±ng m!\")\n",
    "    exit()\n",
    "\n",
    "# üî• Gi·∫£i b√†i to√°n s·ª≠ d·ª•ng Simplex\n",
    "solver = LN_programming(n, F, A, B)\n",
    "optimal_value = solver.solve()\n",
    "\n",
    "if optimal_value != \"UNBOUNDED\":\n",
    "    solver.setX()\n",
    "    print(n)\n",
    "    print(*solver.x[:n].tolist())\n",
    "else:\n",
    "    print(\"UNBOUNDED\")\n",
    "    \n"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "base",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.12.3"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
